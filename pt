#!/usr/bin/perl

use 5.006;
use strict;
use warnings;

# #!/bin/sh
# #! -*- perl -*-
# eval 'exec perl -x -S $0 ${1+"$@"} ;'
# 	if 0;
# # Above lines are for portable Perl startup honoring PATH and emacs.  Don't
# # change lightly.  Options may be inserted before "-x".  For background see
# # "perldoc perlrun" and http://cr.yp.to/slashpackage/studies/findingperl/7 .
# # Developers may need to run as "perl -x -Mblib ..." or "perl -x -Ilib ...".
# # XXX above lines as of 8/3/2009


# xxx support for shadow tree of deletions? pairtree_trash?

my $VERSION = $File::Pairtree::VERSION;

use File::Pairtree;
use File::Path;
use File::Find;		# for lstree, lsnode
use File::ANVL;		# for om_* output multiplexor routines

use Pod::Usage;
# this :config allows -h24w80 for '‐h 24 ‐w 80', -vax for --vax or --Vax
use Getopt::Long qw(:config bundling_override);

my $dir;	# global defining our directory, ends in "pairtree_root"

my $R = $File::Pairtree::root;

my $om;				# output multiplexor routine
my %o;				# global to communicate options to module

my %opt = (
	all		=> 0,
	bud		=> 0,
	directory	=> 0,
	force		=> 0,
	format		=> 0,
	help		=> 0,
	long		=> 0,
	man		=> 0,
	version		=> 0,
	verbose		=> 0,
);

# main
{
	GetOptions(\%opt,
		'all|a',
		'bud|b=s',		# xxx not implemented yet
		'directory|d=s',
		'force|f',
		'format|m=s',		# xxx not implemented yet
		'help|h|?',
		'long|l',
		'man',
		'version',
		'verbose|v',
	)
			or  pod2usage(-exitstatus => 2, -verbose => 1);

	$opt{help}	and pod2usage(-exitstatus => 0, -verbose => 1);
	$opt{man}	and pod2usage(-exitstatus => 0, -verbose => 2);
	$opt{version}	and print("$VERSION\n"), exit(0);

	$om = "om_" .			# initialize output multiplexor
		($opt{format} || "plain");
	defined(&$om)	or pod2usage("$0: unknown format: $opt{format}");
	# xxxxx  $o{om} = $om;
	$opt{bud} = 0;		# xxx temporary kludge

	my $cmd = shift @ARGV;
	defined($cmd)	or pod2usage("$0: no command given");
	$cmd = "do_" . lc($cmd);
	defined(&$cmd)	or pod2usage("$0: unknown command: $cmd");

	# Which pairtree?
	#
	$dir = $opt{directory} || ".";
	$dir = prep_file($dir, $R);

	no strict 'refs';		# permits the next call
	#exit &$cmd(@ARGV);
	my $ret = &$cmd(@ARGV);
	#print "ret=$ret\n";
	exit $ret;
}

# Prepare base path with last component according to the table, normalizing
# multiple slashes between $base and $last.  Useful to get tedious details
# right and when path may already have the last component on it (in which
# case we don't want it there twice).  Removes final slashes from $last.
#
# 	$base		$last		Returns
#  1.	/		bar		/bar
#  2.	.		bar		bar
#  3.	foo		bar		foo/bar
#  4.	foo/		bar		foo/bar
#  5.	foo/bar		bar		foo/bar
#  6.	bar		bar		bar
#
# Main use case, bar=pairtree_root  
# xxx may not port to Windows due to use of explicit slashes (/)
# XXXXXX probably should use File::Spec
# xxx do some test cases for this
# xxx find a better name
sub prep_file { my( $base, $last )=@_;

	$last =~ s{/*(.*)/*$}{$1};	# remove bounding slashes
	return "/$last"		if $base =~ m{^/+$};	# case 1 eliminated
	$base =~ s{/+$}{};		# remove trailing slashes
	return "$last"		if $base =~ m{^\./+$};	# case 2 eliminated
	return "$base/$last"	if $base !~ m{$last$};	# cases 3-4 gone
	return "$last"		if $base =~ m{^$last$};	# case 6 eliminated
	$base =~ s{/*$last$}{};		# remove $last and preceding slashes
	return "$base/$last";				# case 5 eliminated
}

#######################
#
# Command functions.
#

sub do_help { my( $topic )=@_;

	$topic ||= "";
	pod2usage(-exitstatus => 0, -verbose => 2)
	#return print "XXX place holder for help on $topic\n";
}

sub do_lsnode { my( @nodes )=@_;

	# Don't allow empty node, especially for rmnode, which could
	# result in a disastrous rmtree against the entire pairtree.
	#
	scalar(@nodes) > 0	or pod2usage("$0: no id given");

	my $exit_status = 0;		# optimistic

	# set options so pt_lsnode doesn't need to compute each time
	$o{parent_dir} = up_dir($dir);
	$o{prefix} = get_prefix( $o{parent_dir} );
	$o{force} = $opt{force};

	my ($id, $ret);
	no strict 'refs';	# turn off complaints about calls to &$om()
	for $id (@nodes) {
		$ret = pt_lsnode($dir, $id, \%o);
		$ret or		# if success
			print(&$om(DATA, $id, $o{bud})),
			next;
		$exit_status = $ret;	# if we get here, we had trouble
		print(&$om(DATA, "error", "$id: $o{msg}"));
	}
	return $exit_status;
}

# XXX lsnode should list (a) ppath, (b) bud, and (c) leaf
#     id | pairpath_root/ab/c | abc | oxum  ???
# pt_lsnode to return ref to array representing a node, each of form
#    (id | ppath | bud (enclosing dirname for leaf) | leaf oxum)
# or (id | "" | ...    <no ppath>) # or (id | ppath | ""     <no bud>>)

sub do_lstree { my( @trees )=@_;

	scalar(@trees) == 0 and
		push(@trees, $dir);	# default if no args

	my $exit_status = 0;		# optimistic

	my ($tree, $ret);
	no strict 'refs';	# turn off complaints about calls to &$om()
	for $tree (@trees) {
		if (! -e $tree) {
			$exit_status = 1;
			print(&$om(DATA, "error",
				"$tree: no such file or directory"));
			next;
		}
		# set prefix based on $tree's parent (from up_dir)
		$o{parent_dir} = up_dir($tree);
		$o{prefix} = get_prefix( $o{parent_dir} );
		$o{force} = $opt{force};
		$o{long} = $opt{long};
		$o{all} = $opt{all};
		$o{om} = \&$om;

		$o{follow_fast} = 1		# xxx set with $opt?
			unless defined $o{follow_fast};
		# Set follow_fast=1 to mean follow symlinks without rigorous
		# checking (faster); it also means that (-X _) works from
		# within &visit without doing an extra stat call, where -X
		# is any file test operator and _ is the magic file handle.

		# optional 3rd arg is &visit function to use instead
		$ret = pt_lstree($tree, \%o);	# xxx set $o{summary} ?
		$ret or		# if success
			#print(&$om(DATA, "summary", $o{summary})),
			next;
		$exit_status = $ret;	# if we get here, we had trouble
		print(&$om(DATA, "error", "$tree: $o{msg}"));
	}
	return $exit_status;
}

sub do_mknode { my( @nodes )=@_;

	# Don't allow empty node, especially for rmnode, which could
	# result in a disastrous rmtree against the entire pairtree.
	#
	scalar(@nodes) > 0	or pod2usage("$0: no id given");

	my $exit_status = 0;	# optimistic

	# set options so pt_mknode doesn't need to compute each time
	$o{parent_dir} = up_dir($dir);
	$o{prefix} = get_prefix( $o{parent_dir} );
	$o{bud_style} = $opt{bud};
	$o{force} = $opt{force};

	my ($id, $ret);
	no strict 'refs';	# turn off complaints about calls to &$om()
	for $id (@nodes) {
		($ret = pt_mknode($dir, $id, \%o)) and
			print(&$om(DATA, $id, $o{bud})),
			next;
		$exit_status = 1;	# if we get here, we had trouble
		print(&$om(DATA, "error", "$id: $o{msg}"));
	}
	return $exit_status;
}

sub do_mktree { my( $tree, $prefix )=@_;

	$tree ||= $dir;			# use default, but only if the
	$tree = prep_file($tree, $R)	# tree wasn't given explicitly
		if ($tree ne $dir);
	
	my $ret = pt_mktree($tree, $prefix, \%o);
	no strict 'refs';	# turn off complaints about calls to &$om()
	$ret and		# if call failed
		print(&$om(DATA, "error", "$tree: $o{msg}")),
		return 1;

	$opt{verbose} and
		print(&$om(DATA, "mktree", $tree));
	return 0;		# success means exit status 0
}

sub do_rmnode { my( @nodes )=@_;

	# Don't allow empty node, especially for rmnode, which could
	# result in a disastrous rmtree against the entire pairtree.
	#
	scalar(@nodes) > 0	or pod2usage("$0: no id given");

	my $exit_status = 0;		# optimistic

	# set options so pt_rmnode doesn't need to compute each time
	$o{parent_dir} = up_dir($dir);
	$o{prefix} = get_prefix( $o{parent_dir} );
	$o{force} = $opt{force};

	my ($id, $ret);
	no strict 'refs';	# turn off complaints about calls to &$om()
	for $id (@nodes) {
		$ret = pt_rmnode($dir, $id, \%o);
		$ret or		# if success
			print(&$om(DATA, $id, $o{bud})),
			next;
		$exit_status = $ret;	# if we get here, we had trouble
		print(&$om(DATA, "error", "$id: $o{msg}"));
	}
	return $exit_status;
}

sub do_rmtree { my( $tree )=@_;

	print "XXX Not implemented yet; use 'rm -r'\n";
	# XXX force use of tree arg
}

sub do_i2p { my( @ids )=@_;

	print id2ppath($_), "\n"	for (@ids);
}

sub do_p2i { my( @paths )=@_;

	print ppath2id($_), "\n"	for (@paths);
}

__END__

=for roff
.nr PS 12p
.nr VS 14.4p

=head1 NAME

pt - pairtree manipulation commands

=head1 SYNOPSIS

=over

=item B<pt> [B<-d dir>] [B<mktree>] I<directory> [I<prefix>]

=item B<pt> [B<-l>] [B<-d dir>] [B<rmtree | lstree>] [I<directory>] ...

=item B<pt> [B<-d dir>] [B<mknode | rmnode | lsnode>] I<id> ...

=item B<pt> [B<i2p | p2i>] I<name> ...

=back

=head1 DESCRIPTION

The B<pt> utility introduces commands that can be used to create,
delete, modify, and report on a pairtree.  When not made explicit via
an argument (see the first two forms above), the pairtree in question
is assumed to reside in a F<pairtree_root/> directory descending from
the current directory or from a directory specified with B<-d>.

The first form creates a pairtree, recording an optional prefix that
will be stripped from an identifier before mapping it to a pairpath
and prepended to an identifier generated from a pairpath.  The second
form deletes or lists an entire tree of nodes.

The third form creates, deletes, or tests the existence of tree nodes
addressed via the identifier corresponding to each node's filesystem
I<pairpath> directory.  When B<mknode> is used with a non-existent
pairtree, it will attempt first to create a pairtree.  After creating a
new pairpath, B<mknode> will create a I<bud> directory to encapsulate
the new tree I<leaf> (that will not otherwise be supplied by B<pt>).

By default, the bud directory name will be taken from the full form of
the identifier.  While a pairpath may have any length, to properly
encapsulate a leaf, there must be one and only one bud, and its name must
be more than two characters long.  An identifier shorter than that
requires padding the bud name on the left with `0' (zero), except for an
empty identifier, when the bud name simply becomes "supernode".

If B<-l> is also given for B<lstree>, the total number of octets and files
within each leaf is listed after its identifier.

The fourth form permits access to the purely lexical lower level
conversion between identifiers and pairpaths (no filesystem lookups
take place).

This alpha-level software has not been extensively tested.

=head1 EXAMPLES

   $ pt mknode foo bar zafp
   ./pairtree_root/fo/o/foo
   ./pairtree_root/ba/r/bar
   ./pairtree_root/za/fp/zafp
   $ pt rmnode bar
   removed: bar | ./pairtree_root/ba/r/
   $ touch ./pairtree_root/za/fp/zafp/{a,b,c}
   $ pt lstree -l
   zafp   0.3
   foo   0.0
   2 objects
   $ pt mknode ab c ''
   ./pairtree_root/ab/0ab
   ./pairtree_root/c/00c
   ./pairtree_root/supernode

=head1 OPTIONS

=over

=item B<-d directory>

Specify pairtree I<directory>.  A "pairtree_root" component will be added on
if not already present in I<directory>.

=item B<-h>, B<--help>

Print extended help documentation.

=item B<-l>, B<--long>

Print more detailed listings.

=item B<--man>

Print full documentation.

=item B<--version>

Print the current version number and exit.

=item B<-bmfa>

Options yet to come, for B<--bud>, B<--format>, B<--force>, B<--all>.

=back

=head1 SEE ALSO

touch(1)

=head1 AUTHOR

John Kunze I<jak at ucop dot edu>

=head1 COPYRIGHT

  Copyright 2009 UC Regents.  Open source Apache License, Version 2.

=begin CPAN

=head1 README

=head1 SCRIPT CATEGORIES

=end CPAN
